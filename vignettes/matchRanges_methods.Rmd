---
title: "matchRanges: supported methods"
author: "Eric S. Davis"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
output:
  rmarkdown::html_document:
    highlight: tango
vignette: |
  %\VignetteIndexEntry{matchRanges: supported methods}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = TRUE
)
```

This vignette demonstrates the supported matching methods (rejection sampling with replacement, nearest neighbor matching with replacement, and rejection sampling without replacement) when the covariates are either continuous, binary, categorical, or when the focal group is larger than the pool (bootstrapping).

First we load our data and add some additional annotations. In this case we add an indicator that shows whether or not our enhancers and promoters are looped (i.e. `loopedEP`), and we also break down the continuous `epDistance` into categorical groups (i.e. `epDistanceGrouped`).

```{r, message=FALSE}
library(nullranges)
library(nullrangesData)
library(plyranges)
# BiocManager::install("PhanstielLab/BentoBox", update = FALSE)
# BiocManager::install("EricSDavis/hictoolsr", update = FALSE)
library(hictoolsr)
library(ggplot2)
library(patchwork)

## Load enh-prom pairs (and shorten the name)
data("enhPromContactFreqHg19")
epp <- enhPromContactFreqHg19

## Load loops
loops <- data.table::fread(system.file("extdata/hic/MOMA_SIP_10kbLoops_Merged.txt",
                           package = 'nullrangesData')) %>% as_ginteractions()

## Annotate looped and unlooped enh-prom pairs
epp$loopedEP <- 0
epp$loopedEP[countOverlaps(epp, loops) >0] <- 1

## Cut enh-prom distance into groups
epp$epDistanceGrouped <-
  cut(epp$epDistance,
      breaks = c(-Inf, 20e03, 40e03, 60e03, 80e03, Inf),
      labels = c("0-20Kb", "20-40Kb", "40-60Kb", "60-80Kb", "80Kb-100Kb"))
```

## Continuous covariate

Lets see how the matching methods perform when matching on a continuous covariate such as the enhancer-promoter distance (`epDistance`)

```{r, fig.width=11, fig.height=4}
## Define focal, pool and covar
focal <- epp[epp$loopedEP == 1]
pool  <- epp[epp$loopedEP == 0]
covar <- ~epDistance

## Implemented matching methods
system.time({
  mgi1 <- matchRanges(focal, pool, covar,
                      method = 'rejection', replace = TRUE)
})

system.time({
  mgi2 <- matchRanges(focal, pool, covar,
                      method = 'nearest', replace = TRUE)
})

system.time({
  mgi3 <- matchRanges(focal, pool, covar,
                      method = 'rejection', replace = FALSE)
})

## Should error (method not implemented)
matchRanges(focal, pool, covar,
            method = 'nearest', replace = FALSE)


## Overviews for each method
overview(mgi1)
overview(mgi2)
overview(mgi3)

## Number of duplicated samples
n1 <- length(which(duplicated(indices(mgi1))))
n2 <- length(which(duplicated(indices(mgi2))))
n3 <- length(which(duplicated(indices(mgi3))))

## Duplicated as a percentage of pool
np1 <- (n1 / length(pool(mgi1))) * 100
np2 <- (n2 / length(pool(mgi2))) * 100
np3 <- (n3 / length(pool(mgi3))) * 100

## Duplicated as a percentage of focal
nf1 <- (n1 / length(focal(mgi1))) * 100
nf2 <- (n2 / length(focal(mgi2))) * 100
nf3 <- (n3 / length(focal(mgi3))) * 100

## Plots for each
p1 <- plot(mgi1, type = 'lines') + 
  ggtitle(label = 'Rejection matching with replacement',
          subtitle = sprintf('%s duplicates; %s%% of pool, %s%% of focal',
                             n1, signif(np1,2), signif(nf1,2)))
p2 <- plot(mgi2, type = 'lines') + 
  ggtitle(label = 'Nearest matching with replacement',
          subtitle = sprintf('%s duplicates; %s%% of pool, %s%% of focal',
                             n2, signif(np2,2), signif(nf2,2)))
p3 <- plot(mgi3, type = 'lines') + 
  ggtitle(label = 'Rejection matching without replacement',
          subtitle = sprintf('%s duplicates; %s%% of pool, %s%% of focal',
                             n3, signif(np3,2), signif(nf3,2)))

p1 + p2 + p3 +
  plot_annotation(
  title = 'Continuous covariate: looped vs. unlooped, covar = ~epDistance'
  )


```

## Discrete (binary) covariate

Lets see how the matching methods perform when matching on a discrete binary covariate such as whether the enhancer-promoter is looped or not (`loopedEP`).

```{r, fig.width=11, fig.height=4}
## Define focal, pool and covar
focal <- epp[epp$epDistance <= 40e03]
pool  <- epp[epp$epDistance > 40e03]
covar <- ~loopedEP

## Convert to factor for overview()
focal$loopedEP <- as.factor(focal$loopedEP)
pool$loopedEP <- as.factor(pool$loopedEP)

## Implemented matching methods
system.time({
  mgi1 <- matchRanges(focal, pool, covar,
                      method = 'rejection', replace = TRUE)
})

system.time({
  mgi2 <- matchRanges(focal, pool, covar,
                      method = 'nearest', replace = TRUE)
})

system.time({
  mgi3 <- matchRanges(focal, pool, covar,
                      method = 'rejection', replace = FALSE)
})

## Should error (method not implemented)
matchRanges(focal, pool, covar,
            method = 'nearest', replace = FALSE)


## Overviews for each method
overview(mgi1) # Rejection matching with replacement
overview(mgi2) # Nearest matching with replacement
overview(mgi3) # Rejection matching without replacement

## Number of duplicated samples
n1 <- length(which(duplicated(indices(mgi1))))
n2 <- length(which(duplicated(indices(mgi2))))
n3 <- length(which(duplicated(indices(mgi3))))

## Duplicated as a percentage of pool
np1 <- (n1 / length(pool(mgi1))) * 100
np2 <- (n2 / length(pool(mgi2))) * 100
np3 <- (n3 / length(pool(mgi3))) * 100

## Duplicated as a percentage of focal
nf1 <- (n1 / length(focal(mgi1))) * 100
nf2 <- (n2 / length(focal(mgi2))) * 100
nf3 <- (n3 / length(focal(mgi3))) * 100

## Plots for each
p1 <- plot(mgi1, type = 'lines') + 
  ggtitle(label = 'Rejection matching with replacement',
          subtitle = sprintf('%s duplicates; %s%% of pool, %s%% of focal',
                             n1, signif(np1,2), signif(nf1,2)))
p2 <- plot(mgi2, type = 'lines') + 
  ggtitle(label = 'Nearest matching with replacement',
          subtitle = sprintf('%s duplicates; %s%% of pool, %s%% of focal',
                             n2, signif(np2,2), signif(nf2,2)))
p3 <- plot(mgi3, type = 'lines') + 
  ggtitle(label = 'Rejection matching without replacement',
          subtitle = sprintf('%s duplicates; %s%% of pool, %s%% of focal',
                             n3, signif(np3,2), signif(nf3,2)))

p1 + p2 + p3 +
  plot_annotation(
    title = 'Discrete (binary) covariate: small vs large epDistance, covar = ~loopedEP'
  )

```

## Discrete (non-binary) covariate

Lets see how the matching methods perform when matching on a discrete non-binary covariate (i.e. categorical covariate) such as which group the epDistance fall into (`epDistanceGrouped`).

```{r, fig.width=11, fig.height=4}

## Define focal, pool and covar
focal <- epp[epp$loopedEP == 1]
pool  <- epp[epp$loopedEP == 0]
covar <- ~epDistanceGrouped

## Implemented matching methods
system.time({
  mgi1 <- matchRanges(focal, pool, covar,
                      method = 'rejection', replace = TRUE)
})

system.time({
  mgi2 <- matchRanges(focal, pool, covar,
                      method = 'nearest', replace = TRUE)
})

system.time({
  mgi3 <- matchRanges(focal, pool, covar,
                      method = 'rejection', replace = FALSE)
})

## Should error (method not implemented)
matchRanges(focal, pool, covar,
            method = 'nearest', replace = FALSE)


## Overviews for each method
overview(mgi1) # Rejection matching with replacement
overview(mgi2) # Nearest matching with replacement
overview(mgi3) # Rejection matching without replacement

## Number of duplicated samples
n1 <- length(which(duplicated(indices(mgi1))))
n2 <- length(which(duplicated(indices(mgi2))))
n3 <- length(which(duplicated(indices(mgi3))))

## Duplicated as a percentage of pool
np1 <- (n1 / length(pool(mgi1))) * 100
np2 <- (n2 / length(pool(mgi2))) * 100
np3 <- (n3 / length(pool(mgi3))) * 100

## Duplicated as a percentage of focal
nf1 <- (n1 / length(focal(mgi1))) * 100
nf2 <- (n2 / length(focal(mgi2))) * 100
nf3 <- (n3 / length(focal(mgi3))) * 100

## Plots for each
p1 <- plot(mgi1, type = 'lines') + 
  ggtitle(label = 'Rejection matching with replacement',
          subtitle = sprintf('%s duplicates; %s%% of pool, %s%% of focal',
                             n1, signif(np1,2), signif(nf1,2)))
p2 <- plot(mgi2, type = 'lines') + 
  ggtitle(label = 'Nearest matching with replacement',
          subtitle = sprintf('%s duplicates; %s%% of pool, %s%% of focal',
                             n2, signif(np2,2), signif(nf2,2)))
p3 <- plot(mgi3, type = 'lines') + 
  ggtitle(label = 'Rejection matching without replacement',
          subtitle = sprintf('%s duplicates; %s%% of pool, %s%% of focal',
                             n3, signif(np3,2), signif(nf3,2)))

p1 + p2 + p3 +
  plot_annotation(
    title = 'Discrete (non-binary) covariate: looped vs. unlooped, covar = ~epDistanceGrouped'
  )

```

## Case where focal \> pool

Finally, lets see how the matching methods perform when the focal group is larger than the pool. In other words, which matching methods can bootstrap from a small pool.

```{r, fig.width=8, fig.height=4}
## Define focal, pool and covar
focal <- epp[epp$epDistance >= 40e03]
pool  <- epp[epp$epDistance <  40e03]
covar = ~loopedEP + contactFreq


## Implemented matching methods

## Expect error
matchRanges(focal, pool, covar,
            method = 'rejection', replace = TRUE)

system.time({
  mgi2 <- matchRanges(focal, pool, covar,
                      method = 'nearest', replace = TRUE)
})

## Expect error
mgi3 <- matchRanges(focal, pool, covar,
                    method = 'rejection', replace = FALSE)

## Expect error (method not implemented)
matchRanges(focal, pool, covar,
            method = 'nearest', replace = FALSE)


## Overviews for each method
overview(mgi2) # Nearest matching with replacement

plot(mgi2, type = 'ridge') + 
  ggtitle(label = 'Nearest matching with replacement (bootstrapping)')

```
